-- ----------------------------------------------------------------
-- Helper functions for parsing a chart

-- Condenses the chart data into its smallest form.
local MinimizeChart = function(chartString)
	local MinimizeMeasure = function(measure)
		local minimal = false
		-- We can potentially minimize the chart to get the most compressed
		-- form of the actual chart data.
		-- NOTE(teejusb): This can be more compressed than the data actually
		-- generated by StepMania. This is okay because the charts would still
		-- be considered equivalent.
		-- E.g. 0000                      0000
		--      0000  -- minimized to -->
		--      0000
		--      0000
		--      StepMania will always generate the former since quarter notes are
		--      the smallest quantization.
		while not minimal and #measure % 2 == 0 do
			-- If every other line is all 0s, we can minimize the measure.
			local allZeroes = true
			for i=2, #measure, 2 do
				-- Check if the row is NOT all zeroes (thus we can't minimize).
				if measure[i] ~= string.rep('0', measure[i]:len()) then
					allZeroes = false
					break
				end
			end

			if allZeroes then
				-- To remove every other element while keeping the
				-- indices valid, we iterate from [2, len(t)/2 + 1].
				-- See the example below (where len(t) == 6).

				-- index: 1 2 3 4 5 6  -> remove index 2
				-- value: a b a b a b

				-- index: 1 2 3 4 5    -> remove index 3
				-- value: a a b a b

				-- index: 1 2 3 4      -> remove index 4
				-- value: a a a b

				-- index: 1 2 3
				-- value: a a a
				for i=2, #measure/2+1 do
					table.remove(measure, i)
				end
			else
				minimal = true
			end
		end
	end

	local finalChartData = {}
	local curMeasure = {}
	for line in chartString:gmatch('[^\n]+') do
		-- If we hit a comma, that denotes the end of a measure.
		-- Try to minimize it, and then add it to the final chart data with
		-- the delimiter.
		-- Note: Semi-colons are already stripped out by the MsdFileParser.
		if line == ',' then
			MinimizeMeasure(curMeasure)

			for row in ivalues(curMeasure) do
				table.insert(finalChartData, row)
			end
			table.insert(finalChartData, ',')
			-- Just keep removing the first element to clear the table.
			-- This way we don't need to wait for the GC to cleanup the unused values.
			for i=1, #curMeasure do
				table.remove(curMeasure, 1)
			end
		else
			table.insert(curMeasure, line)
		end
	end

	-- Add the final measure.
	if #curMeasure > 0 then
		MinimizeMeasure(curMeasure)

		for row in ivalues(curMeasure) do
			table.insert(finalChartData, row)
		end
	end

	return table.concat(finalChartData, '\n')
end

-- Given a string like "X=Y", where X and Y are decimals, we normalize X and Y to to to 
-- 3 significant places.
local NormalizeFloatDigits = function(param)
	-- V3, uses a faster version of math.floor(x - 0.5) for rounding (no function call).
	--   the V2 version would fail on "82.0625" where it would round it to 82.062 instead
	--   of the expected 82.063
	local NormalizeDecimal = function(decimal)
		-- Remove any control characters from the string to prevent conversion failures.
		decimal = decimal:gsub("%c", "")
		local rounded = tonumber(decimal)

		-- Round to 3 decimal places
		local mult = 10^3
		rounded = (rounded * mult + 0.5 - (rounded * mult + 0.5) % 1) / mult
		return string.format("%.3f", rounded)
	end

	local paramParts = {}
	for beat_bpm in param:gmatch('[^,]+') do
		local beat, bpm = beat_bpm:match('(.+)=(.+)')
		table.insert(paramParts, NormalizeDecimal(beat) .. '=' .. NormalizeDecimal(bpm))
	end
	return table.concat(paramParts, ',')
end

local GetPartsSM = function(msdFile)
	local allNotes = {}

	for value in ivalues(msdFile) do
		if value[1] == 'BPMS' then
			allNotes['BPMS'] = NormalizeFloatDigits(value[2])
		elseif value[1] == 'NOTES' or value[1] == 'NOTES2' then
			-- StepMania considers NOTES sections with greater than 7 sections valid in SM Files.
			-- https://github.com/stepmania/stepmania/blob/master/src/NotesLoaderSM.cpp#L1072-L1079
			if #value >= 7 then
				table.insert(allNotes, {})

				allNotes[#allNotes]['STEPSTYPE'] = value[2]
				allNotes[#allNotes]['DESCRIPTION'] = value[3]
				allNotes[#allNotes]['DIFFICULTY'] = value[4]
				allNotes[#allNotes]['NOTES'] = MinimizeChart(value[7])
				-- Copy over the (already normalized) top level BPMs to the chart level.
				-- This way the allNotes returned by both GetPartsSM and GetPartsSSC will have the
				-- same structure.
				if allNotes['BPMS'] ~= nil then
					allNotes[#allNotes]['BPMS'] = allNotes['BPMS']
				end
			end
		end
	end

	-- Trace(TableToString(allNotes))

	return allNotes
end

local GetPartsSSC = function(msdFile)
	local allNotes = {}
	local readingSongInfo = true

	-- SSC files have "SONG_INFO" and "STEP_INFO" sections.
	-- It starts by reading the SONG_INFO section, and when we come across a NOTEDATA value,
	-- we swap to parse a new "STEP_INFO" section.
	-- Each "STEP_INFO" section ends after processing either a NOTES/NOTES2 or STEPFILENAME field
	-- where it then swaps back to the "SONG_INFO" section.
	-- You can view StepMania implementation here:
	-- https://github.com/stepmania/stepmania/blob/5_1-new/src/NotesLoaderSSC.cpp#L977-L1041
	for value in ivalues(msdFile) do
		if readingSongInfo then
			if value[1] == 'BPMS' then
				-- This is the top level BPM, which might be different than the per chart BPM.
				allNotes['BPMS'] = NormalizeFloatDigits(value[2])
			elseif value[1] == 'NOTEDATA' then
				-- Start reading note data. Insert a nested table to hold all the values.
				readingSongInfo = false
				table.insert(allNotes, {})
			end
		else
			if value[1] == 'BPMS' then
				-- If per chart BPM exists, save it.
				allNotes[#allNotes]['BPMS'] = NormalizeFloatDigits(value[2])
			elseif value[1] == 'STEPSTYPE' or value[1] == 'DESCRIPTION' or value[1] == 'DIFFICULTY' then
				-- We want the description in order to handle edit data.
				allNotes[#allNotes][value[1]] = value[2]
			elseif value[1] == 'NOTES' or value[1] == 'NOTES2' then
				readingSongInfo = true
				-- There are no subsections to the NOTES field unlike SM files (which have 7 or more).
				allNotes[#allNotes]['NOTES'] = MinimizeChart(value[2])
			elseif value[1] == 'STEPFILENAME' then
				readingSongInfo = true
			end
		end
	end

	return allNotes
end


-- ----------------------------------------------------------------
-- Measure Counter/Breakdown generation

-- Figure out which measures are considered a stream of notes
-- Returns a table and the number of total measures.
-- The returned table looks like { 2, 3, 4, 9, 10} which indicate
-- which specific measures in the chart are streams.
local GetStreamMeasures = function(noteData, timingData)
	if noteData['NOTES'] == nil then return {} end

	local notesPerMeasure = 16

	-- Stream Measures Variables
	-- Which measures are considered a stream?
	local streamMeasures = {}
	local measureCount = 1
	local notesInMeasure = 0

	-- NPS and Density Graph Variables
	local density = {}
	local NPSForThisMeasure, peakNPS, BPM = 0, 0, 0


	-- Loop through each line in our string of measures, trimming potential leading whitespace (thanks, TLOES/Mirage Garden)
	for line in noteData['NOTES']:gmatch("[^%s*\r\n]+") do
		-- If we hit a comma or a semi-colon, then we've hit the end of our measure
		if(line:match("^[,;]%s*")) then
			-- Does the number of notes in this measure meet our threshold to be considered a stream?
			if(notesInMeasure >= notesPerMeasure) then
				table.insert(streamMeasures, measureCount)
			end

			-- NPS Calculation
			if timingData ~= nil then
				durationOfMeasureInSeconds = timingData:GetElapsedTimeFromBeat((measureCount+1) * 4) - timingData:GetElapsedTimeFromBeat(measureCount*4)

				-- FIXME: We subtract the time at the current measure from the time at the next measure to determine
				-- the duration of this measure in seconds, and use that to calculate notes per second.
				--
				-- Measures *normally* occur over some positive quantity of seconds.  Measures that use warps,
				-- negative BPMs, and negative stops are normally reported by the SM5 engine as having a duration
				-- of 0 seconds, and when that happens, we safely assume that there were 0 notes in that measure.
				--
				-- This doesn't always hold true.  Measures 48 and 49 of "Mudkyp Korea/Can't Nobody" use a properly
				-- timed negative stop, but the engine reports them as having very small but positive durations
				-- which erroneously inflates the notes per second calculation.

				if durationOfMeasureInSeconds == 0 then
					NPSForThisMeasure = 0
				else
					NPSForThisMeasure = notesInMeasure/durationOfMeasureInSeconds
				end

				-- measureCount in SM truly starts at 0, but Lua's native ipairs() iterator needs indexed tables
				-- that start at 1. Add 1 now so the table behaves and subtract 1 later when drawing the histogram.
				density[measureCount+1] = NPSForThisMeasure

				-- determine whether this measure contained the PeakNPS
				if NPSForThisMeasure > peakNPS then
					peakNPS = NPSForThisMeasure
				end
			end

			-- Reset iterative variables
			notesInMeasure = 0
			measureCount = measureCount + 1
		else
			-- Is this a note? (Tap, Hold Head, Roll Head)
			if(line:match("[124]")) then
				notesInMeasure = notesInMeasure + 1
			end
		end
	end

	return streamMeasures, measureCount, peakNPS, density
end

-- Get the start/end of each stream or break sequence from our table of stream measures
local GetStreamSequences = function(streamMeasures, totalMeasures)
	local streamSequences = {}
	-- Count every measure as stream/non-stream.
	-- We can then later choose how we want to display the information.
	local measureSequenceThreshold = 1

	local counter = 1
	local streamEnd = nil

	-- First add an initial break if it's larger than measureSequenceThreshold
	if #streamMeasures > 0 then
		local breakStart = 0
		local k, v = next(streamMeasures) -- first element of a table
		local breakEnd = streamMeasures[k] - 1
		if (breakEnd - breakStart >= measureSequenceThreshold) then
			table.insert(streamSequences,
				{streamStart=breakStart, streamEnd=breakEnd, isBreak=true})
		end
	end

	-- Which sequences of measures are considered a stream?
	for k,v in pairs(streamMeasures) do
		local curVal = streamMeasures[k]
		local nextVal = streamMeasures[k+1] and streamMeasures[k+1] or -1

		-- Are we still in sequence?
		if curVal + 1 == nextVal then
			counter = counter + 1
			streamEnd = curVal + 1
		else
			-- Found the first section that counts as a stream
			if(counter >= measureSequenceThreshold) then
				if streamEnd == nil then
					streamEnd = curVal
				end
				local streamStart = (streamEnd - counter)
				-- Add the current stream.
				table.insert(streamSequences,
					{streamStart=streamStart, streamEnd=streamEnd, isBreak=false})
			end

			-- Add any trailing breaks if they're larger than measureSequenceThreshold
			local breakStart = curVal
			local breakEnd = (nextVal ~= -1) and nextVal - 1 or totalMeasures
			if (breakEnd - breakStart >= measureSequenceThreshold) then
				table.insert(streamSequences,
					{streamStart=breakStart, streamEnd=breakEnd, isBreak=true})
			end
			counter = 1
			streamEnd = nil
		end
	end

	return streamSequences
end


-- Stream Sequences, Peak NPS, and Density calculations

-- GetStreams() accepts two arguments:
--      noteData, a table containing all the information for the current steps
-- 		song, a song object provided by something like GAMESTATE:GetCurrentSong()
--
-- GetStreams() returns three values:
--      StreamSequences, a table containing the sections of the chart that can be considered stream or break
--		PeakNPS, a number representing the peak notes-per-second for the given stepchart
--			This is an imperfect measurement, as we sample the note density per-second-per-measure, not per-second.
--			It is (unlikely but) possible for the true PeakNPS to be spread across the boundary of two measures.
--		Density, a numerically indexed table containing the notes-per-second value for each measure
--			The Density table is indexed from 1 (as Lua tables go); simfile charts, however, start at measure 0.
--			So if you're looping through the Density table, subtract 1 from the current index to get the
--			actual measure number.
local GetStreams = function(noteData, song)
	if noteData['NOTES'] == nil then return {} end

	local timingData = nil
	if noteData['STEPSTYLE'] ~= nil and noteData['DIFFICULTY'] ~= nil then
		timingData = song:GetOneSteps(
			StepsStyle:Reverse()["StepsStyle_" .. noteData['STEPSTYLE']],
			Difficulty:Reverse()["Difficulty_" .. noteData['DIFFICULTY']])
	end

	-- Which measures have enough notes to be considered as part of a stream?
	local streamMeasures, totalMeasures, peakNps, density = GetStreamMeasures(noteData, timingData)

	-- Which sequences of measures are considered a stream?
	return GetStreamSequences(streamMeasures, totalMeasures), peakNps, density
end

-- ----------------------------------------------------------------
-- Hash Generation

local GenerateHash = function(noteData, topLevelBpm)
	local bpms = topLevelBpm

	-- If we find split BPMs for this chart, then they have higher precedence.
	if noteData['BPMS'] ~= nil then
		bpms = noteData['BPMS']
	end
	if bpms == '' or noteData['NOTES'] == nil then return '' end

	local chartDataAndBpm =  noteData['NOTES'] .. bpms

	-- using CRYPTMAN's SHA256String to compute a hash is ~4 orders of magnitude faster
	-- computing the same hash using Lua.  CRYPTMAN.SHA256String() and BinaryToHex() were
	-- made available to Lua for SM5.1, see: https://github.com/stepmania/stepmania/pull/2053
	-- These won't be in SM5.0.12, so ensure they're available before using them.
	if CRYPTMAN.SHA256String ~= nil and type(BinaryToHex)=="function" then
		return BinaryToHex( CRYPTMAN:SHA256String(chartDataAndBpm) )
	else
		Trace("Using bad")
		-- pure-Lua implementation of SHA256
		-- see: ./SL/Scripts/sha2for51.lua
		return sha256(chartDataAndBpm)
	end

	return ''
end


-- ----------------------------------------------------------------

ParseChartData = function(song)
	-- The Song StepMania class doesn't allow you to get the filename while
	-- the Steps StepMania class does.
	-- We assume that all the steps come from the same file so we just get the
	-- filename from the first set of steps we encounter.
	local allSteps = song:GetAllSteps()
	if #allSteps == 0 then return end
	local fileName = allSteps[1]:GetFilename()

	-- We've already parsed this file and it's in the cache. Ignore this call.
	if SL.FileCache.Path ~= nil and SL.FileCache.Path == fileName then return end

	SL.FileCache.Path = filename
	-- Get the full raw parsed MSD File
	local x = GetTimeSinceStart()
	local msdFile, fileType = ParseMsdFile(fileName)
	if #msdFile == 0 then return end
	local y = GetTimeSinceStart()
	Trace("MSD FILE TOOK: " ..tostring(y-x))
	x = y

	-- Extract only the relevant parts from the MsdFile we care about
	-- These values will be normalized and the chart data will be minimized.
	local allNotes = {}
	if fileType == 'sm' then
		allNotes = GetPartsSM(msdFile)
	elseif fileType == 'ssc' then
		allNotes = GetPartsSSC(msdFile)
	else
		return
	end
	if #allNotes == 0 then return end
	y = GetTimeSinceStart()
	Trace("GET PARTS TOOK: " ..tostring(y-x))
	x = y

	-- The top level BPM used for Hash Generation.
	topLevelBpm = ''
	if allNotes['BPMS'] ~= nil then
		topLevelBpm = allNotes['BPMS']
	end

	for noteData in ivalues(allNotes) do
		-- We have top level fields that aren't tables.
		-- The actual noteData is always a subtable.
		if type(noteData) == 'table' then
			local stepsType = noteData['STEPSTYPE']
			local difficulty = noteData['DIFFICULTY']
			local description = noteData['DESCRIPTION']
			if stepsType ~= nil and difficulty ~= nil and description ~= nil then
				local hash = GenerateHash(noteData, topLevelBpm)
				y = GetTimeSinceStart()
				Trace("HASH GENERATION TOOK: " ..tostring(y-x))
				x = y
				local streams, peakNps, density = GetStreams(noteData, song)
				y = GetTimeSinceStart()
				Trace("GET STREAMS TOOK: " ..tostring(y-x))
				x = y
				SL.FileCache[#SL.FileCache+1] = {
					stepsType, difficulty, description, --[[ hash,]] streams, peakNps, density
				}
			end
			
		end
	end

	-- Trace(TableToString(SL.FileCache))
end